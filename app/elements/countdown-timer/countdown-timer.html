<!--
Copyright 2016 Google Inc. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at
  http://www.apache.org/licenses/LICENSE-2.0
Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<link rel="import" href="../../bower_components/polymer/polymer.html">

<script src="countdown-timer-namespace.js"></script>
<script src="countdown-timer-enumerations.js"></script>
<script src="countdown-timer-renderer.js"></script>
<script src="countdown-timer.js"></script>

<!--
Creates a countdown timer to a specific date.

##### Example

    <countdown-timer date="May 10 2016 09:00:00 GMT-0700 (PDT)"></countdown-timer>

##### Example - all attributes

    <countdown-timer
        class="io-countdown-timer"
        auto-start
        date="May 10 2016 09:00:00 GMT-0700 (PDT)"
        date-adjustment="3"
        ease-in-time="500"
        wait-time="300"
        ease-out-time="400"
        bg-color="red"></countdown-timer>
-->
<dom-module id="countdown-timer">
  <template>
    <style>
      :host {
        display: block;
        width: 100%;
        height: 100%;
        opacity: 0;
        transition: opacity 400ms cubic-bezier(0,0,0.2,1);
        will-change: opacity;
      }
      .countdown-timer,
      #surface {
        width: 100%;
        height: 100%;
      }
    </style>
    <div class="countdown-timer">
      <canvas id="surface"></canvas>
    </div>
  </template>
  <script>
    (function() {
      Polymer({
        is: 'countdown-timer',

        properties: {
          /**
           * Whether or not the countdown should begin immediately.
           */
          autoStart: {
            type: Boolean,
            value: false
          },

          /**
           * Fades in the countdown when it's attached to the DOM.
           */
          autoShow: {
            type: Boolean,
            value: false
          },

          /**
           * Background color for the countdown.
           */
          bgColor: {
            type: String,
            observer: '_bgColorChanged'
          },

          /**
           * The target date for the countdown. Should be specified in ISO 8601
           * format, e.g. `May 10 2016 09:00:00 GMT-0700 (PDT)`.
           */
          date: {
            type: String,
            value: 'May 10 2016 09:00:00 GMT-0700 (PDT)',
            observer: '_configChanged'
          },

          /**
           * `dateAdjustment` adds the specified number of days to count down before
           * displaying the final count. So, for example, if it is 75 days to the
           * target date, a `dateAdjustment` of 3 will start the countdown at 78.
           */
          dateAdjustment: {
            type: Number,
            value: 3,
            observer: '_configChanged'
          },

          /**
           * The time, in milliseconds, that it takes for a number to transition in.
           */
          easeInTime: {
            type: Number,
            value: 500,
            observer: '_configChanged'
          },

          /**
           * The time, in milliseconds, that a number takes to transition out.
           */
          easeOutTime: {
            type: Number,
            value: 400,
            observer: '_configChanged'
          },

          /**
           * Used in the element's aria-label to describe what the countdown
           * is countdown to.
           */
          label: {
            type: String,
            value: ''
          },

          /**
           * If true, the countdown has reached the end.
           */
          ended: {
            type: Boolean,
            value: false,
            notify: true,
            readOnly: true,
            reflectToAttribute: true
          },

          thresholdInformation: {
            value: function() {
              return {
                thresholdDays: false,
                thresholdHours: false,
                thresholdMinutes: false,
                thresholdSeconds: false
              };
            },
            notify: true
          },


          /**
           * The underlying timer object.
           */
          timer: {
            readOnly: true,
            value: null
          },

          /**
           * The current value of the countdown.
           */
          value: {
            value: null,
            notify: true
          },

          /**
           * The time, in milliseconds, that a number stays on screen.
           */
          waitTime: {
            type: Number,
            value: 300,
            observer: '_configChanged'
          }
        },

        /**
         * Fired when a new day/hour/seconds threshold is reached.
         *
         * @event timerthreshold
         * @param {Object} thresholdInformation
         */

        /**
         * Fired the current timer value has decremented.
         *
         * @event timertick
         * @param {Object} currentValue
         */

        ready: function() {
          IOWA.CountdownTimer.Colors.Background = this.bgColor;
        },

        /**
         * Lifecycle event that creates the timer, configures it, and either
         * starts it (if `autoStart` === true) or draws the start value if not.
         */
        attached: function() {
          // Create the timer and set it with whatever the current
          // values are. If the user updates any values then the
          // timer will get reconfigured.
          this._setTimer(new IOWA.CountdownTimer.Element(this.$.surface));
          this._configureTimer();
          this.timer.setOnTimerThresholdReachedCallback(this._onTimerThresholdReached.bind(this));
          this.timer.setOnTimerTickCallback(this._onTimerTick.bind(this));

          if (!this.autoStart) {
            this.timer.drawIfAnimationIsNotRunning();
            return;
          }
          this.start();
          if (this.autoShow) {
            this.show();
          }
        },

        detached: function() {
          this.timer.destroy();
        },

        /**
         * Stops the timer.
         */
        stop: function() {
          this.timer.stop();
        },

        /**
         * Starts the timer.
         */
        start: function() {
          this.timer.start();
        },

        /**
         * Resets the timer.
         */
        reset: function() {
          this._configureTimer();
          this.timer.drawIfAnimationIsNotRunning();
        },

        /**
         * Forces the canvas to reassess and adopt
         * its parent's dimensions.
         */
        show: function() {
          if (!this.timer) {
            return;
          }
          Polymer.dom(this).node.style.opacity = 0;
          // Fade in the countdown timer
          this.timer.resizeRenderer();
          Polymer.dom(this).node.style.opacity = 1;
        },

        _configChanged: function() {
          if (!this.timer) {
            return;
          }
          this._configureTimer();
          this.timer.drawIfAnimationIsNotRunning();
        },

        _bgColorChanged: function() {
          IOWA.CountdownTimer.Colors.Background = this.bgColor;
        },

        /**
         * Fires an event from the countdown timer when it has reached a
         * threshold, e.g. changed from hours to minutes, or the timer has
         * finished.
         *
         * @param {{label: string, millisecondsToTarget: number, ended: boolean}} passes the label and the milliseconds remaining.
         */
        _onTimerThresholdReached: function(thresholdInformation) {
          this.thresholdInformation = {
            thresholdDays: false,
            thresholdHours: false,
            thresholdMinutes: false,
            thresholdSeconds: false
          };
          switch (thresholdInformation.label) {
            case 'Days':
              this.set('thresholdInformation.thresholdDays', true);
              break;
            case 'Hours':
              this.set('thresholdInformation.thresholdHours', true);
              break;
            case 'Minutes':
              this.set('thresholdInformation.thresholdMinutes', true);
              break;
            case 'Seconds':
              this.set('thresholdInformation.thresholdSeconds', true);
              break;
          }
          if (thresholdInformation.millisecondsToTarget === 0) {
            this._setEnded(true);
            this.set('thresholdInformation.ended', true);
          }
          this.fire('timerthreshold', thresholdInformation);
        },

        _onTimerTick: function(currentValue) {
          this.value = currentValue;
          var label = this.label ? ', until ' + this.label : '';
          Polymer.dom(this).setAttribute('aria-label',
              currentValue.days + ' days, ' +
              currentValue.hours + ' hours, ' +
              currentValue.minutes + ' minutes, ' +
              currentValue.seconds + ' seconds' + label);
        },

        /**
         * Used to take the current values from the element's prototype to set
         * the corresponding values on the timer.
         */
        _configureTimer: function() {
          if (!this.timer) {
            return;
          }
          var targetDate = Date.parse(this.date);
          if (isNaN(targetDate)) {
            targetDate = Date.now();
          }
          targetDate = new Date(targetDate);
          this.timer.configure({
            targetDate: targetDate,
            adjustmentInDays: this.dateAdjustment,
            easeInTime: this.easeInTime,
            waitTime: this.waitTime,
            easeOutTime: this.easeOutTime
          });
        }
      });
    }());
  </script>
</dom-module>
